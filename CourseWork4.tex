\documentclass[a4paper,14pt]{extarticle}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage[dvips]{graphicx}
\usepackage{color}
\usepackage[dvips]{hyperref}

%\usepackage{minted}

\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{textcomp}
\usepackage{ifthen}
\usepackage{calc}

\hypersetup{%
	unicode,%
	linkcolor=blue,
	colorlinks=true,%
%	pdfpagemode=FullScreen,%
%	pdfpagetransition=Dissolve,%
	pdftitle={Курсовая работа по дисциплине "Фундаментальная информатика"},%
}


\thispagestyle{empty}

\setlength{\voffset}{-.8in}
\setlength{\hoffset}{-.75in}
\addtolength{\textheight}{1.6in}
\addtolength{\textwidth}{1.5in}


\onehalfspacing

%Поменяйте фамилию, имя и отчество в команде FIO
\newcommand{\FIO}{Нягин Анатолий Сергеевич}

%Поменяйте название программного продукта в команде SOFTWARE
\newcommand{\SOFTWARE}{MATH INTERPRETER}

%Укажите номер группы (110 или 111)
\newcommand{\GROUP}{110}

\begin{document}
\input{titulCW}
\newpage

\tableofcontents
\newpage

\section{Техническое задание}
\textbf{Интерпретатор математических выражений}
\begin{itemize}
	\item Распознавание математического выражения с операциями +,–,×,÷,\,{$\hat{} $}
	
	\item Проверка корректности ввода, в том числе корректной расстановки скобок
	
	\item Поддержка добавления и использования однобуквенных переменных (сохранение после работы в файл)
	
	\item Загрузка при старте переменных из файла
	
	\item Очистка переменных
\end{itemize}

%Требуется вставить техническое задание на Ваше ПО.
\subsection{Функциональные возможности приложения}
Данное приложение способно вычислять значения любых математических выражений с операциями +,–,×,÷,\,{$\hat{} $}\,{.}  
Имеется возможность определять однобуквенные переменные (всего 52: a..z,A..Z), а после использовать
определенные переменные в математических выражениях.
Определенные переменные можно сохранить в файл с помощью соответствующей команды save.
Можно запустить команды интерпретатора из другого файла с помощью соответствующей команды run.
Можно узнать краткую справку по возможностям интерпретатора и примерами ввода с помощью команды info.
Команда exit завершает работу интерпретатора с очисткой выделенной под программу памяти, а
определенные переменные записывает в файл с именем "ProgramVarsAfterExit.txt".
%Описать функциональные возможности приложения 
Входные данные всегда являются командами от пользователя в терминал.
При желании, можно запустить команды из файла, но для этого нужно в терминале
в запущенном интерпретаторе написать команду run с именем запускаемого файла.
%Описать входные данные, принимаемые приложением


\section{Руководство пользователя}
%Описать интерфейс приложения и взаимодействие с пользователем.
Запуск и все взаимодействие с пользователем производится в терминале.
 
После запуска приложение встречает нас именем ПО, заключенным в рамку, и кратчайшей справкой по
командам info и exit. После идут символы {>}{>}{>} после которых и просится запись команды интерпретатору.
Пустая строка или строка состоящая из пробелов вызывают ожидание новой команды от пользователя.
Пробелы в начале команды игнорируются интерпретатором. Максимальная длина команды - 200.
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{1.jpeg}
	\end{center}
	\caption{Запуск ПО.}
\end{figure}

%Привести пример корректной работы приложения (со скриншотами).
Можно записать явно математическое выражение с числами и скобками, интерпретатор выведет значение выражения. Список
допустимых операций: +,–,×,÷,\,{$\hat{} $}\,{.} Интерпретатор принимает числа со значащими нулями. Если число дробное, то перед и после точки должна быть цифра.
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{2.jpeg}
	\end{center}
	\caption{Результаты разных математических выражений}
\end{figure}

Можно определить однобуквенную переменную. Для этого требуется записать команду в формате: <var\_name> = <math\_expression>.
Переменной присвоется значения выражения.
После можно использовать определенные переменные в математических выражениях. Можно узнать значения этих переменных.
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{34.jpeg}
	\end{center}
	\caption{Переменные}
\end{figure}

Определенные переменные можно сохранить в файл с помощью команды save <file\_name>. Перед ключевым словом save и именем файла
пробелом может и не быть. Считывание имени файла начинается с первого после ключевого save непробельного символа и до конца команды.
Если в директории ПО нету файла с таким именем, то создастся новый, и тут запишутся построчно переменные в формате <var\_name> = <var\_value>. Если такой файл есть, то данные переменных перезапишутся.
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{5.jpeg}
	\end{center}
	\caption{Команда save сохраняет определенные переменные в файл <<ab>>}
\end{figure}
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{5a.jpeg}
	\end{center}
	\caption{Содержимое файла <<ab>>}
\end{figure}

Можно запустить заранее написанные команды из файла с помощью команды run <file\_name>. Перед ключевым словом run и именем файла
пробелом может и не быть. Считывание имени файла начинается с первого после ключевого run непробельного символа и до конца команды.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{6.jpeg}
	\end{center}
	\caption{Команда run запустила те же переменные, которые были ранее сохранены командой save}
\end{figure}

Можно быстро узнать возможности интерпретатора с помощью ключевого слова info. После и перед командой не должно быть непробельных символов, пробелы игнорируются.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.4]{7.jpeg}
	\end{center}
	\caption{Команда info дает краткую инструкцию к интерпретатору}
\end{figure}

Программу можно завершить с помощью ключевого слова exit. После и перед командой не должно быть непробельных символов, пробелы игнорируются. Перед завершением интерпретатора все определенные во время работы переменные записываются в файл <<ProgramVarsAfterExit.txt>>, а вся выделенная память под программу очищается.
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{8a.jpeg}
	\end{center}
	\caption{Команда exit закрыла программу и сохранила определенные переменные в файл <<ProgramVarsAfterExit.txt>>}
\end{figure}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{8.jpeg}
	\end{center}
	\caption{Содержимое файла <<ProgramVarsAfterExit.txt>>}
\end{figure}

%Описать реакцию приложения на аномалии входных данных.
В случае, если на вход интерпретатору дать некорректную команду, он выведет тип ошибки с описанием самой ошибки. Всего обрабатывается
21 видов ошибок. Если это возможно, выводится индекс места в строке команды, в которой произошла ошибка.
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{9.jpeg}
	\end{center}
	\caption{На аномальные входные данные программа выводит тип ошибки}
\end{figure}

\newpage
\section{Структура приложения}
%Описывается логика работы приложения, основые блоки и модули, а также взаимодействие между ними.
ПО состоит из файлов: main.c, main.h, interpreter.c, interpreter.h, mathexpression.c, mathexpression.h, errors.c, errors.h, stack.c,  stack.h. 

В main.c находится часть, отвечающая за прием ввода от пользователя, вывода имени ПО и краткой справки. Введеная пользователем строка подается на вход функции do\_command\_line, реализованной в interpreter.c. При некорректности введенной строки запускается функция print\_error из errors.c. В main.h записаны подключения всех заголовочных файлов, требуемых для работы всей программы. 

В interpreter.c находится реализация функции do\_command\_line, отвечающей за определение вида команды, парсинг строки и определение вида ошибки в случае некорректности ввода. Если поданная строка представляет собой команду info, то в функции do\_command\_line запускается функция print\_info, которая была определена в interpreter.c. Функция print\_info выводит краткую инструкцию по ПО в stdout. Если поданная строка является командой save, то в функции do\_command\_line вызывается функция save\_vars\_to\_file, определенная в interpreter.c, куда аргументом подаются имя файла и указатель на структуру Variables, которая хранит в себе значения однобуквенных переменных. Структура Variables описана в mathexpression.h. Если поданная строка представляет собой команду run, то в функции do\_command\_line вызывается функция run\_commands\_from\_file, определенная в interpreter.c, куда аргументами подаются имя запускаемого файла и указатель на стркуктуру Variables. Функция run\_commands\_from\_file рекурсивно вызывает функцию do\_dommand\_line к строкам файла. Если команда содержит математическое выражение, то в функции do\_dommand\_line вызывается функция math\_expression, которая была определена в mathexpression.c, куда аргументами подаются строка с математическим выражением, указатель на структуру Variables, откуда в случае чего будут браться значения переменных и указатель на переменную типа double, куда сохранится значение математического выражения в случае корректности. Функция do\_dommand\_line возвращает структуру Pair с полем number равным номеру ошибки, если она есть, и с полем index равным индексу места в строке команды, в котором произошла ошибка. Если ошибок не произошло, то возвращается Pair с полем number равным 0. 

В mathexpression.c определены expression\_value и вспомогательные функции. В их числе 
get\_nan - функция, возвращающая nan;
do\_vars\_empty - функция, делающая все значения переменных в структуре, переданной по указателю - nan (неопределенными);
is\_only\_binary\_oper - функция, возвращающая 1, если поданный в нее аргумент один из символов +,–,×,÷,\,{$\hat{} $}, иначе 0;
is\_oper - функция, возвращающая 1, если поданный в нее аргумент является символом операции, иначе 0;
maybe\_is\_correct\_sym - функция, возвращающая 1, если поданный в нее аргумент является допустимым в мат. выражении, иначе 0;
operate - функция, принимающая аргументы, операцию и возвращающая результат операции к аргументам;
priority - функция, принимающая символ операции и возвращающая ее приоритет (1, 2, 3);
var\_index - функция, принимающая символ (имя переменной) и возвращающая индекс в массиве;
var\_value - функция, принимающая символ (имя переменной) и возвращающая ее значение;

Функция expression\_value вычисляет значение переданного математического выражения, в котором
могут находиться однобуквенные переменные из переданной структуры по указателю. Если
математическое выражение корректно, то по переданному указателю result записывается значение
выражения и возвращается структура Pair с полем number равным 0. Иначе result
не меняется, а функция возвращает Pair с полем number равным номеру ошибки и
с полем index равным индексу места в строке expression, в котором произошла ошибка. В функции используются вспомогательные функции и структура Stack и объединение union Elem, определенные в stack.h, и функции create\_stack, delete\_stack, pop, top, push, определенные в stack.c.

Структура Stack представляет собой односвязный список, построенной на структуре Node. Полем значения узла односвязного списка
является объединение union Elem, который может в себе хранить char и double.
Функция create\_stack выделяет на куче память для структуры Stack и возвращает указатель на эту область памяти.
Функция delete\_stack принимает указатель на указатель на структуру Stack и освобождает память, выделенную под нее.
Функция push принимает указатель на структуру Stack и значение типа Elem и ставит значение на вершину стека.
Функция pop принимает указатель на структуру Stack и указатель на тип Elem, снимает значение с вершины стека и сохраняет по переданному указателю.
Функция top принимает указатель на структуру Stack и указатель на тип Elem, копирует значение с вершины стека и сохраняет по переданному указателю.
%Перечислить разработанные модули и функции.  
%Описать последовательность вызовов функций. 

\section{Основные алгоритмы}
%Здесь приводятся алгоритмы, используемые автором
%Описать работу каждой функции: входные и выходные параметры, схему работы (блок-схема, псевдокод или словесное описание).
%Не в виде кода!!!
Основным используемым алгоритмом является алгоритм сортировочной станции Дейкстры для вычисления математического выражения.

Алгоритм:

Стек символов;

Стек чисел.

Пока строка не пустая:

	{\setlength{\leftskip}{2em}
	
	Если объект - число, то кладем на вершину стека чисел.
	
	Если объект - открывающая скобка, то кладем на вершину стека символов.
	
	Если объект - операция, то
	
		{\setlength{\leftskip}{4em}
		
		Если стек символов пуст, то кладем объект на вершину стека символов.
		
		Если символ на вершине стека символов является открывающей скобкой, то кладем объект на вершину стека символов.
		
		Если символ на вершине стека является операцией, то
		
			{\setlength{\leftskip}{6em}
			
			Если объект - возведение в степень и символ с вершины стека - унарный минус, то кладем объект на стек символов.
			
			Если объект - возведение в степень и символ с вершины стека - возведение в степень, то кладем объект на стек символов.
			
			Если объект - унарный минус и символ с вершины стека - возведение в степень, то кладем объект на стек символов.
			
			Если объект - унарный минус и символ с вершины стека - унарный минус, то кладем объект на стек символов.
			
			Если приоритет объекта строго больше приоритета символа с вершины стека, то кладем объект на стек символов.
			
			Иначе {
			
				\setlength{\leftskip}{8em}
				Пока (стек символов не пуст) и (символ с вершины стека символов - операция) и (приоритет символа с вершины стека строго больше приоритета объекта)
				
					{\setlength{\leftskip}{10em}
					
					Взять число со стека чисел. (первое число)
					
					Если символ со стека символов - унарный минус, то снять символ со стека символов, применить к первому числу и положить обратно на стек чисел.
					
					Иначе взять число со стека чисел (второе число), снять символ со стека символов, применить операцию ко второму числу и первому в данном порядке и положить результат на стек чисел.
					}
				}
			}
		}
	
	Если объект - закрывающая скобка, то
	
	{\setlength{\leftskip}{4em}
		Взять число со стека чисел. (первое число)
		
		Если символ со стека символов - унарный минус, то снять символ со стека символов, применить к первому числу и положить обратно на стек чисел.
		
		Иначе взять число со стека чисел (второе число), снять символ со стека символов, применить операцию ко второму числу и первому в данном порядке и положить результат на стек чисел.
	}
}

Пока стек символов не пуст:

{\setlength{\leftskip}{2em}
	Взять число со стека чисел. (первое число)
	
	Если символ со стека символов - унарный минус, то снять символ со стека символов, применить к первому числу и положить обратно на стек чисел.
	
	Иначе взять число со стека чисел (второе число), снять символ со стека символов, применить операцию ко второму числу и первому в данном порядке и положить результат на стек чисел.

}

\section{Список использованных источников}
%Здесь должен быть список литературы, статей и прочих материалов, использованных в работе. 

\section{Приложение}
%Приводится код. Каждый файл в своём подразделе.
\subsection{main.c}
%\inputminted{C}{main.c}

\subsection{main.h}
%\inputminted{C}{main.h}

\subsection{interpreter.c}
%\inputminted{C}{interpreter.c}

\subsection{interpreter.h}
%\inputminted{C}{interpreter.h}

\subsection{mathexpression.c}
%\inputminted{C}{mathexpression.c}

\subsection{mathexpression.h}
%\inputminted{C}{mathexpression.h}

\subsection{errors.c}
%\inputminted{C}{errors.c}

\subsection{errors.h}
%\inputminted{C}{errors.h}

\subsection{stack.c}
%\inputminted{C}{stack.c}

\subsection{stack.h}
%\inputminted{C}{stack.h}




\end{document}
